/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['sha1.js']) {
  _$jscoverage['sha1.js'] = [];
  _$jscoverage['sha1.js'][10] = 0;
  _$jscoverage['sha1.js'][12] = 0;
  _$jscoverage['sha1.js'][13] = 0;
  _$jscoverage['sha1.js'][14] = 0;
  _$jscoverage['sha1.js'][15] = 0;
  _$jscoverage['sha1.js'][16] = 0;
  _$jscoverage['sha1.js'][17] = 0;
  _$jscoverage['sha1.js'][19] = 0;
  _$jscoverage['sha1.js'][26] = 0;
  _$jscoverage['sha1.js'][27] = 0;
  _$jscoverage['sha1.js'][28] = 0;
  _$jscoverage['sha1.js'][34] = 0;
  _$jscoverage['sha1.js'][35] = 0;
  _$jscoverage['sha1.js'][37] = 0;
  _$jscoverage['sha1.js'][39] = 0;
  _$jscoverage['sha1.js'][40] = 0;
  _$jscoverage['sha1.js'][42] = 0;
  _$jscoverage['sha1.js'][44] = 0;
  _$jscoverage['sha1.js'][45] = 0;
  _$jscoverage['sha1.js'][47] = 0;
  _$jscoverage['sha1.js'][49] = 0;
  _$jscoverage['sha1.js'][50] = 0;
  _$jscoverage['sha1.js'][52] = 0;
  _$jscoverage['sha1.js'][54] = 0;
  _$jscoverage['sha1.js'][55] = 0;
  _$jscoverage['sha1.js'][57] = 0;
  _$jscoverage['sha1.js'][59] = 0;
  _$jscoverage['sha1.js'][60] = 0;
  _$jscoverage['sha1.js'][62] = 0;
  _$jscoverage['sha1.js'][67] = 0;
  _$jscoverage['sha1.js'][68] = 0;
  _$jscoverage['sha1.js'][74] = 0;
  _$jscoverage['sha1.js'][76] = 0;
  _$jscoverage['sha1.js'][77] = 0;
  _$jscoverage['sha1.js'][79] = 0;
  _$jscoverage['sha1.js'][80] = 0;
  _$jscoverage['sha1.js'][81] = 0;
  _$jscoverage['sha1.js'][82] = 0;
  _$jscoverage['sha1.js'][83] = 0;
  _$jscoverage['sha1.js'][84] = 0;
  _$jscoverage['sha1.js'][86] = 0;
  _$jscoverage['sha1.js'][87] = 0;
  _$jscoverage['sha1.js'][88] = 0;
  _$jscoverage['sha1.js'][89] = 0;
  _$jscoverage['sha1.js'][90] = 0;
  _$jscoverage['sha1.js'][91] = 0;
  _$jscoverage['sha1.js'][93] = 0;
  _$jscoverage['sha1.js'][94] = 0;
  _$jscoverage['sha1.js'][95] = 0;
  _$jscoverage['sha1.js'][98] = 0;
  _$jscoverage['sha1.js'][100] = 0;
  _$jscoverage['sha1.js'][102] = 0;
  _$jscoverage['sha1.js'][103] = 0;
  _$jscoverage['sha1.js'][104] = 0;
  _$jscoverage['sha1.js'][105] = 0;
  _$jscoverage['sha1.js'][106] = 0;
  _$jscoverage['sha1.js'][109] = 0;
  _$jscoverage['sha1.js'][110] = 0;
  _$jscoverage['sha1.js'][111] = 0;
  _$jscoverage['sha1.js'][112] = 0;
  _$jscoverage['sha1.js'][113] = 0;
  _$jscoverage['sha1.js'][115] = 0;
  _$jscoverage['sha1.js'][123] = 0;
  _$jscoverage['sha1.js'][124] = 0;
  _$jscoverage['sha1.js'][125] = 0;
  _$jscoverage['sha1.js'][127] = 0;
  _$jscoverage['sha1.js'][128] = 0;
  _$jscoverage['sha1.js'][130] = 0;
  _$jscoverage['sha1.js'][131] = 0;
  _$jscoverage['sha1.js'][133] = 0;
  _$jscoverage['sha1.js'][139] = 0;
  _$jscoverage['sha1.js'][140] = 0;
  _$jscoverage['sha1.js'][147] = 0;
  _$jscoverage['sha1.js'][148] = 0;
  _$jscoverage['sha1.js'][149] = 0;
  _$jscoverage['sha1.js'][150] = 0;
  _$jscoverage['sha1.js'][153] = 0;
  _$jscoverage['sha1.js'][154] = 0;
  _$jscoverage['sha1.js'][155] = 0;
  _$jscoverage['sha1.js'][156] = 0;
  _$jscoverage['sha1.js'][159] = 0;
  _$jscoverage['sha1.js'][160] = 0;
  _$jscoverage['sha1.js'][167] = 0;
  _$jscoverage['sha1.js'][168] = 0;
  _$jscoverage['sha1.js'][169] = 0;
  _$jscoverage['sha1.js'][170] = 0;
  _$jscoverage['sha1.js'][176] = 0;
  _$jscoverage['sha1.js'][177] = 0;
  _$jscoverage['sha1.js'][184] = 0;
  _$jscoverage['sha1.js'][185] = 0;
  _$jscoverage['sha1.js'][186] = 0;
  _$jscoverage['sha1.js'][187] = 0;
  _$jscoverage['sha1.js'][188] = 0;
  _$jscoverage['sha1.js'][189] = 0;
  _$jscoverage['sha1.js'][191] = 0;
  _$jscoverage['sha1.js'][196] = 0;
  _$jscoverage['sha1.js'][197] = 0;
  _$jscoverage['sha1.js'][198] = 0;
  _$jscoverage['sha1.js'][199] = 0;
  _$jscoverage['sha1.js'][200] = 0;
  _$jscoverage['sha1.js'][201] = 0;
  _$jscoverage['sha1.js'][203] = 0;
  _$jscoverage['sha1.js'][208] = 0;
  _$jscoverage['sha1.js'][209] = 0;
  _$jscoverage['sha1.js'][210] = 0;
  _$jscoverage['sha1.js'][211] = 0;
  _$jscoverage['sha1.js'][212] = 0;
  _$jscoverage['sha1.js'][215] = 0;
  _$jscoverage['sha1.js'][217] = 0;
  _$jscoverage['sha1.js'][222] = 0;
  _$jscoverage['sha1.js'][223] = 0;
  _$jscoverage['sha1.js'][224] = 0;
  _$jscoverage['sha1.js'][225] = 0;
  _$jscoverage['sha1.js'][226] = 0;
  _$jscoverage['sha1.js'][229] = 0;
  _$jscoverage['sha1.js'][231] = 0;
  _$jscoverage['sha1.js'][232] = 0;
  _$jscoverage['sha1.js'][235] = 0;
  _$jscoverage['sha1.js'][237] = 0;
}
_$jscoverage['sha1.js'][10]++;
(function () {
  _$jscoverage['sha1.js'][12]++;
  var root = this;
  _$jscoverage['sha1.js'][13]++;
  var exports;
  _$jscoverage['sha1.js'][14]++;
  var crypto;
  _$jscoverage['sha1.js'][15]++;
  if (typeof module === "undefined") {
    _$jscoverage['sha1.js'][16]++;
    root.weibo = root.weibo || {};
    _$jscoverage['sha1.js'][17]++;
    exports = root.weibo.sha1 = {};
  }
  else {
    _$jscoverage['sha1.js'][19]++;
    exports = module.exports;
  }
  _$jscoverage['sha1.js'][26]++;
  var hexcase = 0;
  _$jscoverage['sha1.js'][27]++;
  var b64pad = "=";
  _$jscoverage['sha1.js'][28]++;
  var chrsz = 8;
  _$jscoverage['sha1.js'][34]++;
  function hex_sha1(s) {
    _$jscoverage['sha1.js'][35]++;
    return binb2hex(core_sha1(str2binb(s), s.length * chrsz));
}
  _$jscoverage['sha1.js'][37]++;
  exports.hex_sha1 = hex_sha1;
  _$jscoverage['sha1.js'][39]++;
  function b64_sha1(s) {
    _$jscoverage['sha1.js'][40]++;
    return binb2b64(core_sha1(str2binb(s), s.length * chrsz));
}
  _$jscoverage['sha1.js'][42]++;
  exports.b64_sha1 = b64_sha1;
  _$jscoverage['sha1.js'][44]++;
  function str_sha1(s) {
    _$jscoverage['sha1.js'][45]++;
    return binb2str(core_sha1(str2binb(s), s.length * chrsz));
}
  _$jscoverage['sha1.js'][47]++;
  exports.str_sha1 = str_sha1;
  _$jscoverage['sha1.js'][49]++;
  function hex_hmac_sha1(key, data) {
    _$jscoverage['sha1.js'][50]++;
    return binb2hex(core_hmac_sha1(key, data));
}
  _$jscoverage['sha1.js'][52]++;
  exports.hex_hmac_sha1 = hex_hmac_sha1;
  _$jscoverage['sha1.js'][54]++;
  function b64_hmac_sha1(key, data) {
    _$jscoverage['sha1.js'][55]++;
    return binb2b64(core_hmac_sha1(key, data));
}
  _$jscoverage['sha1.js'][57]++;
  exports.b64_hmac_sha1 = b64_hmac_sha1;
  _$jscoverage['sha1.js'][59]++;
  function str_hmac_sha1(key, data) {
    _$jscoverage['sha1.js'][60]++;
    return binb2str(core_hmac_sha1(key, data));
}
  _$jscoverage['sha1.js'][62]++;
  exports.str_hmac_sha1 = str_hmac_sha1;
  _$jscoverage['sha1.js'][67]++;
  function sha1_vm_test() {
    _$jscoverage['sha1.js'][68]++;
    return hex_sha1("abc") === "a9993e364706816aba3e25717850c26c9cd0d89d";
}
  _$jscoverage['sha1.js'][74]++;
  function core_sha1(x, len) {
    _$jscoverage['sha1.js'][76]++;
    x[len >> 5] |= 128 << (24 - len % 32);
    _$jscoverage['sha1.js'][77]++;
    x[((len + 64 >> 9) << 4) + 15] = len;
    _$jscoverage['sha1.js'][79]++;
    var w = new Array(80);
    _$jscoverage['sha1.js'][80]++;
    var a = 1732584193;
    _$jscoverage['sha1.js'][81]++;
    var b = -271733879;
    _$jscoverage['sha1.js'][82]++;
    var c = -1732584194;
    _$jscoverage['sha1.js'][83]++;
    var d = 271733878;
    _$jscoverage['sha1.js'][84]++;
    var e = -1009589776;
    _$jscoverage['sha1.js'][86]++;
    for (var i = 0; i < x.length; i += 16) {
      _$jscoverage['sha1.js'][87]++;
      var olda = a;
      _$jscoverage['sha1.js'][88]++;
      var oldb = b;
      _$jscoverage['sha1.js'][89]++;
      var oldc = c;
      _$jscoverage['sha1.js'][90]++;
      var oldd = d;
      _$jscoverage['sha1.js'][91]++;
      var olde = e;
      _$jscoverage['sha1.js'][93]++;
      for (var j = 0; j < 80; j++) {
        _$jscoverage['sha1.js'][94]++;
        if (j < 16) {
          _$jscoverage['sha1.js'][95]++;
          w[j] = x[i + j];
        }
        else {
          _$jscoverage['sha1.js'][98]++;
          w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
        }
        _$jscoverage['sha1.js'][100]++;
        var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
        _$jscoverage['sha1.js'][102]++;
        e = d;
        _$jscoverage['sha1.js'][103]++;
        d = c;
        _$jscoverage['sha1.js'][104]++;
        c = rol(b, 30);
        _$jscoverage['sha1.js'][105]++;
        b = a;
        _$jscoverage['sha1.js'][106]++;
        a = t;
}
      _$jscoverage['sha1.js'][109]++;
      a = safe_add(a, olda);
      _$jscoverage['sha1.js'][110]++;
      b = safe_add(b, oldb);
      _$jscoverage['sha1.js'][111]++;
      c = safe_add(c, oldc);
      _$jscoverage['sha1.js'][112]++;
      d = safe_add(d, oldd);
      _$jscoverage['sha1.js'][113]++;
      e = safe_add(e, olde);
}
    _$jscoverage['sha1.js'][115]++;
    return [a, b, c, d, e];
}
  _$jscoverage['sha1.js'][123]++;
  function sha1_ft(t, b, c, d) {
    _$jscoverage['sha1.js'][124]++;
    if (t < 20) {
      _$jscoverage['sha1.js'][125]++;
      return (b & c) | ((~ b) & d);
    }
    _$jscoverage['sha1.js'][127]++;
    if (t < 40) {
      _$jscoverage['sha1.js'][128]++;
      return b ^ c ^ d;
    }
    _$jscoverage['sha1.js'][130]++;
    if (t < 60) {
      _$jscoverage['sha1.js'][131]++;
      return (b & c) | (b & d) | (c & d);
    }
    _$jscoverage['sha1.js'][133]++;
    return b ^ c ^ d;
}
  _$jscoverage['sha1.js'][139]++;
  function sha1_kt(t) {
    _$jscoverage['sha1.js'][140]++;
    return (t < 20)? 1518500249: (t < 40)? 1859775393: (t < 60)? -1894007588: -899497514;
}
  _$jscoverage['sha1.js'][147]++;
  function core_hmac_sha1(key, data) {
    _$jscoverage['sha1.js'][148]++;
    var bkey = str2binb(key);
    _$jscoverage['sha1.js'][149]++;
    if (bkey.length > 16) {
      _$jscoverage['sha1.js'][150]++;
      bkey = core_sha1(bkey, key.length * chrsz);
    }
    _$jscoverage['sha1.js'][153]++;
    var ipad = new Array(16), opad = new Array(16);
    _$jscoverage['sha1.js'][154]++;
    for (var i = 0; i < 16; i++) {
      _$jscoverage['sha1.js'][155]++;
      ipad[i] = bkey[i] ^ 909522486;
      _$jscoverage['sha1.js'][156]++;
      opad[i] = bkey[i] ^ 1549556828;
}
    _$jscoverage['sha1.js'][159]++;
    var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
    _$jscoverage['sha1.js'][160]++;
    return core_sha1(opad.concat(hash), 672);
}
  _$jscoverage['sha1.js'][167]++;
  function safe_add(x, y) {
    _$jscoverage['sha1.js'][168]++;
    var lsw = (x & 65535) + (y & 65535);
    _$jscoverage['sha1.js'][169]++;
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    _$jscoverage['sha1.js'][170]++;
    return (msw << 16) | (lsw & 65535);
}
  _$jscoverage['sha1.js'][176]++;
  function rol(num, cnt) {
    _$jscoverage['sha1.js'][177]++;
    return (num << cnt) | (num >>> (32 - cnt));
}
  _$jscoverage['sha1.js'][184]++;
  function str2binb(str) {
    _$jscoverage['sha1.js'][185]++;
    var bin = Array();
    _$jscoverage['sha1.js'][186]++;
    var mask = (1 << chrsz) - 1;
    _$jscoverage['sha1.js'][187]++;
    for (var i = 0; i < str.length * chrsz; i += chrsz) {
      _$jscoverage['sha1.js'][188]++;
      bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i % 32);
}
    _$jscoverage['sha1.js'][189]++;
    return bin;
}
  _$jscoverage['sha1.js'][191]++;
  exports.str2binb = str2binb;
  _$jscoverage['sha1.js'][196]++;
  function binb2str(bin) {
    _$jscoverage['sha1.js'][197]++;
    var str = "";
    _$jscoverage['sha1.js'][198]++;
    var mask = (1 << chrsz) - 1;
    _$jscoverage['sha1.js'][199]++;
    for (var i = 0; i < bin.length * 32; i += chrsz) {
      _$jscoverage['sha1.js'][200]++;
      str += String.fromCharCode((bin[i >> 5] >>> (32 - chrsz - i % 32)) & mask);
}
    _$jscoverage['sha1.js'][201]++;
    return str;
}
  _$jscoverage['sha1.js'][203]++;
  exports.binb2str = binb2str;
  _$jscoverage['sha1.js'][208]++;
  function binb2hex(binarray) {
    _$jscoverage['sha1.js'][209]++;
    var hex_tab = hexcase? "0123456789ABCDEF": "0123456789abcdef";
    _$jscoverage['sha1.js'][210]++;
    var str = "";
    _$jscoverage['sha1.js'][211]++;
    for (var i = 0; i < binarray.length * 4; i++) {
      _$jscoverage['sha1.js'][212]++;
      str += hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8 + 4)) & 15) + hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8)) & 15);
}
    _$jscoverage['sha1.js'][215]++;
    return str;
}
  _$jscoverage['sha1.js'][217]++;
  exports.binb2hex = binb2hex;
  _$jscoverage['sha1.js'][222]++;
  function binb2b64(binarray) {
    _$jscoverage['sha1.js'][223]++;
    var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    _$jscoverage['sha1.js'][224]++;
    var str = "";
    _$jscoverage['sha1.js'][225]++;
    for (var i = 0; i < binarray.length * 4; i += 3) {
      _$jscoverage['sha1.js'][226]++;
      var triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 255) << 16) | (((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 255) << 8) | ((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 255);
      _$jscoverage['sha1.js'][229]++;
      for (var j = 0; j < 4; j++) {
        _$jscoverage['sha1.js'][231]++;
        if (i * 8 + j * 6 > binarray.length * 32) {
          _$jscoverage['sha1.js'][231]++;
          str += b64pad;
        }
        else {
          _$jscoverage['sha1.js'][232]++;
          str += tab.charAt((triplet >> 6 * (3 - j)) & 63);
        }
}
}
    _$jscoverage['sha1.js'][235]++;
    return str;
}
  _$jscoverage['sha1.js'][237]++;
  exports.binb2b64 = binb2b64;
})();
_$jscoverage['sha1.js'].source = ["/*"," * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined"," * in FIPS PUB 180-1"," * Version 2.1a Copyright Paul Johnston 2000 - 2002."," * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet"," * Distributed under the BSD License"," * See http://pajhome.org.uk/crypt/md5 for details."," */","","(function () {","","var root = this; // window on browser","var exports;","var crypto;","if (typeof module === 'undefined') {","  root.weibo = root.weibo || {};","  exports = root.weibo.sha1 = {};","} else {","  exports = module.exports;","}","","/*"," * Configurable variables. You may need to tweak these to be compatible with"," * the server-side, but the defaults work in most cases."," */","var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */","var b64pad  = \"=\"; /* base-64 pad character. \"=\" for strict RFC compliance   */","var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */","","/*"," * These are the functions you'll usually want to call"," * They take string arguments and return either hex or base-64 encoded strings"," */","function hex_sha1(s) {","  return binb2hex(core_sha1(str2binb(s), s.length * chrsz));","}","exports.hex_sha1 = hex_sha1;","","function b64_sha1(s) {","  return binb2b64(core_sha1(str2binb(s), s.length * chrsz));","}","exports.b64_sha1 = b64_sha1;","","function str_sha1(s) { ","  return binb2str(core_sha1(str2binb(s), s.length * chrsz));","}","exports.str_sha1 = str_sha1;","","function hex_hmac_sha1(key, data) { ","  return binb2hex(core_hmac_sha1(key, data));","}","exports.hex_hmac_sha1 = hex_hmac_sha1;","","function b64_hmac_sha1(key, data) { ","  return binb2b64(core_hmac_sha1(key, data));","}","exports.b64_hmac_sha1 = b64_hmac_sha1;","","function str_hmac_sha1(key, data) { ","  return binb2str(core_hmac_sha1(key, data));","}","exports.str_hmac_sha1 = str_hmac_sha1;","","/*"," * Perform a simple self-test to see if the VM is working"," */","function sha1_vm_test() {","  return hex_sha1(\"abc\") === \"a9993e364706816aba3e25717850c26c9cd0d89d\";","}","","/*"," * Calculate the SHA-1 of an array of big-endian words, and a bit length"," */","function core_sha1(x, len) {","  /* append padding */","  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);","  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;","","  var w = new Array(80);","  var a =  1732584193;","  var b = -271733879;","  var c = -1732584194;","  var d =  271733878;","  var e = -1009589776;","","  for (var i = 0; i &lt; x.length; i += 16) {","    var olda = a;","    var oldb = b;","    var oldc = c;","    var oldd = d;","    var olde = e;","","    for (var j = 0; j &lt; 80; j++) {","      if (j &lt; 16) {","        w[j] = x[i + j];","      }","      else {","        w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);","      }","      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),","                       safe_add(safe_add(e, w[j]), sha1_kt(j)));","      e = d;","      d = c;","      c = rol(b, 30);","      b = a;","      a = t;","    }","","    a = safe_add(a, olda);","    b = safe_add(b, oldb);","    c = safe_add(c, oldc);","    d = safe_add(d, oldd);","    e = safe_add(e, olde);","  }","  return [ a, b, c, d, e ];","","}","","/*"," * Perform the appropriate triplet combination function for the current"," * iteration"," */","function sha1_ft(t, b, c, d) {","  if (t &lt; 20) {","    return (b &amp; c) | ((~b) &amp; d);","  }","  if (t &lt; 40) {","    return b ^ c ^ d;","  }","  if (t &lt; 60) {","    return (b &amp; c) | (b &amp; d) | (c &amp; d);","  }","  return b ^ c ^ d;","}","","/*"," * Determine the appropriate additive constant for the current iteration"," */","function sha1_kt(t) {","  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :","         (t &lt; 60) ? -1894007588 : -899497514;","}","","/*"," * Calculate the HMAC-SHA1 of a key and some data"," */","function core_hmac_sha1(key, data) {","  var bkey = str2binb(key);","  if (bkey.length &gt; 16) {","    bkey = core_sha1(bkey, key.length * chrsz);","  }","","  var ipad = new Array(16), opad = new Array(16);","  for(var i = 0; i &lt; 16; i++) {","    ipad[i] = bkey[i] ^ 0x36363636;","    opad[i] = bkey[i] ^ 0x5C5C5C5C;","  }","","  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);","  return core_sha1(opad.concat(hash), 512 + 160);","}","","/*"," * Add integers, wrapping at 2^32. This uses 16-bit operations internally"," * to work around bugs in some JS interpreters."," */","function safe_add(x, y) {","  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);","  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);","  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);","}","","/*"," * Bitwise rotate a 32-bit number to the left."," */","function rol(num, cnt) {","  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));","}","","/*"," * Convert an 8-bit or 16-bit string to an array of big-endian words"," * In 8-bit function, characters &gt;255 have their hi-byte silently ignored."," */","function str2binb(str) {","  var bin = Array();","  var mask = (1 &lt;&lt; chrsz) - 1;","  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)","    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);","  return bin;","}","exports.str2binb = str2binb;","","/*"," * Convert an array of big-endian words to a string"," */","function binb2str(bin) {","  var str = \"\";","  var mask = (1 &lt;&lt; chrsz) - 1;","  for(var i = 0; i &lt; bin.length * 32; i += chrsz)","    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);","  return str;","}","exports.binb2str = binb2str;","","/*"," * Convert an array of big-endian words to a hex string."," */","function binb2hex(binarray) {","  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";","  var str = \"\";","  for(var i = 0; i &lt; binarray.length * 4; i++) {","    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +","     hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);","  }","  return str;","}","exports.binb2hex = binb2hex;","","/*"," * Convert an array of big-endian words to a base-64 string"," */","function binb2b64(binarray) {","  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";","  var str = \"\";","  for(var i = 0; i &lt; binarray.length * 4; i += 3) {","    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)","                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )","                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);","    for(var j = 0; j &lt; 4; j++)","    {","      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;","      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);","    }","  }","  return str;","}","exports.binb2b64 = binb2b64;","","})();"];
